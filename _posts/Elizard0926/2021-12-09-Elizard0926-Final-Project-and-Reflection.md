---
layout: post
author: Elizard0926
title: "Elizabeth's Final Project & Reflection"
---

# Game Program Trinket
<iframe src="https://trinket.io/embed/python/988cc6790a" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

# Reflection
For my final project, I chose to make a text-adventure game loosely based on the story of Hansel and Gretel in Grimm's Fairy Tales. The decision to pursue this project was largely inspired by a previous class I took on video games and virtual worlds where we learned about an early popular text-adventure game called *Zork*. At the beginning of this project, I had grand ambitions of offering the user multiple choices for movement (North, South, East, West) which would subsequently trigger different events (e.g. opening door, grab key, etc.). However, when it came time to write up our first interface draft, I quickly realized that writing my program was as much a challenge of organizing data in the code as it was processing it in my mind. For that reason, the final form of my program is much simpler. I decided to scale back the progression of events by presenting the player with at most two options and a very clear path to the end.

In many ways, the “beating heart” of this program is the dictionary. Though it was said many times in class, the idea that dictionaries are powerful did not mean that much to me until I had to use it and reference it multiple times while working on my program. In that first interface draft, the hardest thing that I had to wrap my head around was the layers of dictionaries and lists. Conceptually, I began with the idea of containing information in “rooms” that the player moves through. The tricky part then was mapping two options to a room, and then attaching additional information that was unique to either option. This is where I used two sets of dictionaries contained in the list value for the room. To get the two options presented to the player, the player had to provide an input that mapped to one of the room names like “KITCHEN” or “PARLOR.” Here, I ran into a couple problems. First, the player did not have any way of knowing what room they were in at the beginning. The work-around was I made the first room in the “rooms” dictionary “START,” and then I had the program ask the user, "Type name of current room or START to begin.” The second problem I ran into was that having the player type the name of the current room manually required them to a) remember the room they were in and b) infer what room they were in based on what option they took. For instance, if a player chose “START” at the beginning, and then they chose to “TRY DOOR” from the two options presented, they are prompted again to "Type name of current room or START to begin.” As the programmer, I know that they are still in the kitchen, but the messaging is less than clear for a new player. Also, having the program continually ask “START to begin” on every turn was a bit confusing.

In the next iteration of my interface, I decided to address the problem of an overly clunky user input by creating a variable to keep track of the current room. This was so that I could use the “next-choice” key (the name of a room like “KITCHEN”) to automatically set the next room based on a user’s choice instead of them having to tell the program themselves which dictionary key to use. At this point, I ran into difficulties because there was an initial state (the START) that I needed to handle before I could set off the convenient chain reaction of events using “next-choice.” This is where I broke out the two steps of user input into two `while` loops. The first I set to `while current_room == None:` since no room key has been called yet. Then, once the player has set the current_room to “START” after being asked to ‘type START to begin’, the program leaves that loop and moves on to the second `while` loop which asks "Do you want to ___ or ___ ." This solved the problem of mixed-messaging that I described earlier since the user is only ever asked to START once (at the beginning), and from there they are asked a sequence of two options prompts. In effect, the program moves the player through the rooms (or makes them stay in a room) without the user ever having to explicitly call that key by quietly running “next-choice” as the key in the background for the next room.

With my core dictionary, there were both struggles and victories. A struggle that I didn’t expect to have was naming. I mentioned the earlier problem of treating keys as rooms even though “START” was a room which was confusing at times. There was also the issue of “choice(s)” vs “option(s).” The nuance between these two words is that choice implies an active decision is or was made, while option refers to something that has a static state which is presented to someone. Even though I knew this, it was still difficult to mentally keep track of these variables. It was especially difficult when these variables would then be set to something else or changed like `room_options` or `user_choice`. A strategy that helped a lot was printing “was selected” or “was chosen” after the player provided input. This caught a lot of errors at the beginning, and it really helped me confirm whether or not the program had understood the user’s input and appropriately selected the next action or key. Something that also helped me with this was writing descriptive comments for myself as I worked. Many of these early comments were revised or deleted in the final version to make the code more readable, but at the time, I found them really helpful. For example, as soon as I successfully was able to capture the player’s input or the program presented the correct options, I’d write a comment that would say exactly where it came from and what was produced (inputs and outputs). A victory I’m proud of is integrating a function within a dictionary value. To fulfill the requirement of using an external data file, I wrote up longer descriptions to be displayed whenever the player entered a new room. I couldn’t find anything explicitly saying if or how functions could be integrated inside dictionaries in the Runestone textbook, so I did consult this [source](https://www.geeksforgeeks.org/python-store-function-as-dictionary-value/) just to confirm that it was possible. Using a custom module, I created two functions that read my room_descriptions file, split and extracted the lines where appropriate, and assigned them to keys in a dictionary. From there, I used that second `get_description function` as a value that mapped to “room_description” inside my main options dictionaries.

In the process of making my program more robust and handling all sorts of inputs from my user, I learned a lot about `while` loops. In total, there are four `while` loops. There is the main `while playing` loop and three other `while` loops nested inside it at various points. The two that gave me the most trouble were the `while curent_room ==None` loop and the `while` loop inside my `get_choice` function. The first `while` loop gave me a lot of trouble because at the time, I had the player’s input set to the variable `current_room`. Every time I gave an invalid input, the program would set `current_room` to that invalid input and exit the loop since `current_room` no longer was `None`. To fix this, I created an entirely new variable called `initialize_game` that would capture the user’s input and then verify it against my if-else conditionals before updating the `current_room` variable. Feeling confident, I moved onto the next part of my program where a user has to give an input. For this second `while` loop that handles the answer to the two option prompt (“Do you want to…”), I didn’t have a convenient variable to set to `None` like I did in the first case. This is where I ran into some trouble understanding when to set things to `None`, `True`, or `False`. Here, I had a light-bulb moment. I decided to make a variable called `‘valid’` which I thought of as a switch. When the switch is engaged (True), the player has to stay inside a loop of being offered two options. When the switch is turned off (False), the player can exit the loop and the game progresses or ends entirely. This helped me keep the player in the “Do you want to” loop no matter what kinds of input were given.

The end result of this game is quite static in the sense that I gave the player the illusion of choice. To make it easier for me, the programmer, I always set the second choice to be the one to move the player from room to room. This forces the player to really only move forward on one path to the end. Given more time, I would have liked to figure out how to create different “endings” or outcomes based on the choices that the user has made. Though this program is nowhere close to the sophistication of *Zork’s* text parser, I am just proud that it works given the fact that I had never written a line of code prior to this class. If anything, I have that much more respect for text-adventure games that can handle user input with noun-verb commands, prepositions, and/or conjunctions. As a final note, I would like to acknowledge that I received a lot of help, and code, from Dr. Hauser especially when it concerns the inventory interface. Much help was given in terms of how to structure the inventory and how to integrate it into my main program. An earlier sketch of my inventory that I spent a lot of time working out and iterating on before bringing it back to the main program can be found [here](https://trinket.io/python/1ec0f7e1b6)).
